# Архитектура погодной станции

## Обзор

Проект погодной станции на ESP32 реализован с применением принципов чистого кода и объектно-ориентированного программирования. Архитектура проекта разбита на несколько ключевых компонентов, каждый из которых отвечает за определенную функциональность.

## Структура проекта

```
/workspace/
├── weather_station.ino          # Основной файл проекта
├── platformio.ini              # Конфигурация PlatformIO
├── README.md                   # Документация проекта
└── docs/
    └── architecture.md         # Документация архитектуры
```

## Компоненты системы

### 1. SensorManager

Класс `SensorManager` отвечает за управление датчиками. Он использует интерфейс `ISensor` для абстракции работы с различными типами датчиков.

**Принципы:**
- Единая ответственность: класс отвечает только за управление датчиками
- Открытость/закрытость: можно легко добавлять новые типы датчиков, реализуя интерфейс `ISensor`
- Инверсия зависимостей: зависит от абстракции, а не от конкретных реализаций

### 2. ISensor Interface

Интерфейс `ISensor` определяет общий контракт для всех датчиков:

```cpp
class ISensor {
public:
    virtual ~ISensor() = default;
    virtual bool initialize() = 0;
    virtual bool readData(WeatherData& data) = 0;
};
```

**Реализации:**
- `DHTSensor`: датчик температуры и влажности DHT22
- `BMP280Sensor`: датчик атмосферного давления BMP280

### 3. DataStorage

Класс `DataStorage` отвечает за хранение и архивирование данных. Он использует SPIFFS (SPI Flash File System) для хранения данных во флэш-памяти ESP32.

**Функциональность:**
- Сохранение текущих данных
- Архивирование данных каждые 7 дней
- Управление историей данных

### 4. WeatherPredictor

Класс `WeatherPredictor` реализует простой алгоритм прогнозирования погоды на основе анализа трендов. Он использует исторические данные для предсказания будущих значений температуры и влажности.

### 5. WebServer

Класс `WebServer` предоставляет веб-интерфейс для доступа к данным. Он реализует простой HTTP-сервер с несколькими маршрутами:
- `/` - главная страница с текущими данными
- `/data` - JSON с текущими погодными данными
- `/predict` - JSON с прогнозом погоды

## Структура данных

Структура `WeatherData` используется для унифицированного представления погодных данных:

```cpp
struct WeatherData {
    float temperature;      // Температура в градусах Цельсия
    float humidity;         // Влажность в процентах
    float pressure;         // Давление в Паскалях
    float predictedTemp;    // Предсказанная температура
    float predictedHumidity; // Предсказанная влажность
    unsigned long timestamp; // Временная метка
};
```

## Конфигурация

Конфигурационные параметры находятся в namespace `WeatherStationConfig`:

```cpp
namespace WeatherStationConfig {
    const char* WIFI_SSID = "WEATHER_STATION_AP";
    const char* WIFI_PASSWORD = "weather123";
    const int DHT_PIN = 4;
    const int DHT_TYPE = DHT22;
    const unsigned long MEASUREMENT_INTERVAL = 60000; // 1 минута
    const unsigned long ARCHIVE_INTERVAL = 604800000; // 7 дней в миллисекундах
    const size_t MAX_DATA_POINTS = 1008; // Количество точек данных за неделю при интервале 10 мин
}
```

## Принципы чистого кода

### Именование

- Все имена переменных, функций и классов имеют осмысленные названия
- Используется camelCase для функций и переменных
- Используется PascalCase для классов
- Используется UPPER_SNAKE_CASE для констант

### Функции

- Функции маленькие и сфокусированы на одной задаче
- Максимальное количество параметров - 2
- Уровни абстракции в функциях единообразны

### Обработка ошибок

- Используются возвращаемые значения для сигнализации об ошибках
- Проверка корректности инициализации компонентов
- Валидация данных перед обработкой

### Комментарии

- Комментарии объясняют "почему", а не "что"
- Код максимально самодокументирован
- Конфигурационные параметры имеют поясняющие комментарии

## Тестирование

Хотя в данном проекте не представлены автоматические тесты, архитектура спроектирована таким образом, чтобы обеспечить тестируемость компонентов:
- Использование интерфейсов позволяет создавать mock-объекты для тестирования
- Маленькие, сфокусированные функции легко тестируются
- Четкое разделение ответственностей позволяет тестировать компоненты изолированно

## Безопасность и надежность

- Проверка возвращаемых значений при работе с датчиками
- Защита от переполнения массивов
- Корректная очистка ресурсов в деструкторах
- Валидация входных данных

## Производительность

- Эффективное использование памяти
- Минимизация динамического выделения памяти в цикле
- Использование статических массивов для хранения истории данных
- Оптимизация сетевых запросов